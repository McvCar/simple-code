"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const schema_1 = require("../schema");
class ArraySchema extends schema_1.Schema {
    constructor(_a) {
        var { valueSchema, name = valueSchema.name } = _a, handlers = tslib_1.__rest(_a, ["valueSchema", "name"]);
        super(Object.assign({}, handlers, { name }));
        this._valueSchema = valueSchema;
    }
    expected(utils) {
        return `an array of ${this._valueSchema.expected(utils)}`;
    }
    validate(value, utils) {
        if (!Array.isArray(value)) {
            return false;
        }
        const invalidValues = [];
        for (const subValue of value) {
            const subValidateResult = utils.normalizeValidateResult(this._valueSchema.validate(subValue, utils), subValue);
            if (subValidateResult !== true) {
                invalidValues.push(subValidateResult.value);
            }
        }
        return invalidValues.length === 0 ? true : { value: invalidValues };
    }
    deprecated(value, utils) {
        const deprecatedResult = [];
        for (const subValue of value) {
            const subDeprecatedResult = utils.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils), subValue);
            if (subDeprecatedResult !== false) {
                deprecatedResult.push(...subDeprecatedResult.map(({ value: deprecatedValue }) => ({
                    value: [deprecatedValue],
                })));
            }
        }
        return deprecatedResult;
    }
    forward(value, utils) {
        const forwardResult = [];
        for (const subValue of value) {
            const subForwardResult = utils.normalizeForwardResult(this._valueSchema.forward(subValue, utils), subValue);
            forwardResult.push(...subForwardResult.map(wrapTransferResult));
        }
        return forwardResult;
    }
    redirect(value, utils) {
        const remain = [];
        const redirect = [];
        for (const subValue of value) {
            const subRedirectResult = utils.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils), subValue);
            if ('remain' in subRedirectResult) {
                remain.push(subRedirectResult.remain);
            }
            redirect.push(...subRedirectResult.redirect.map(wrapTransferResult));
        }
        return remain.length === 0 ? { redirect } : { redirect, remain };
    }
    overlap(currentValue, newValue) {
        return currentValue.concat(newValue);
    }
}
exports.ArraySchema = ArraySchema;
function wrapTransferResult({ from, to }) {
    return { from: [from], to };
}
