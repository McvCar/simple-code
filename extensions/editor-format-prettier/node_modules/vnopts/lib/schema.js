"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const HANDLER_KEYS = [
    'default',
    'expected',
    'validate',
    'deprecated',
    'forward',
    'redirect',
    'overlap',
    'preprocess',
    'postprocess',
];
function createSchema(SchemaConstructor, parameters) {
    const schema = new SchemaConstructor(parameters);
    const subSchema = Object.create(schema);
    for (const handlerKey of HANDLER_KEYS) {
        if (handlerKey in parameters) {
            subSchema[handlerKey] = normalizeHandler(parameters[handlerKey], schema, Schema.prototype[handlerKey].length);
        }
    }
    return subSchema;
}
exports.createSchema = createSchema;
class Schema {
    constructor(parameters) {
        this.name = parameters.name;
    }
    static create(parameters) {
        // @ts-ignore: https://github.com/Microsoft/TypeScript/issues/5863
        return createSchema(this, parameters);
    }
    default(_utils) {
        return undefined;
    }
    // istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`
    expected(_utils) {
        return 'nothing';
    }
    // istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`
    validate(_value, _utils) {
        return false;
    }
    deprecated(_value, _utils) {
        return false;
    }
    forward(_value, _utils) {
        return undefined;
    }
    redirect(_value, _utils) {
        return undefined;
    }
    overlap(currentValue, _newValue, _utils) {
        return currentValue;
    }
    preprocess(value, _utils) {
        return value;
    }
    postprocess(value, _utils) {
        return value;
    }
}
exports.Schema = Schema;
function normalizeHandler(handler, superSchema, handlerArgumentsLength) {
    return typeof handler === 'function'
        ? (...args) => handler(...args.slice(0, handlerArgumentsLength - 1), superSchema, ...args.slice(handlerArgumentsLength - 1))
        : () => handler;
}
